"use strict";(self.webpackChunkzano_docs=self.webpackChunkzano_docs||[]).push([[594],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,h=d["".concat(l,".").concat(m)]||d[m]||u[m]||r;return n?i.createElement(h,o(o({ref:t},p),{},{components:n})):i.createElement(h,o({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:a,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3374:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var i=n(7462),a=(n(7294),n(3905));const r={},o="Serialization Types in the Zano Codebase",s={unversionedId:"code/serialization-types",id:"code/serialization-types",title:"Serialization Types in the Zano Codebase",description:"In the Zano codebase you may encounter a concept called a serialization map. In fact, you will see three different serialization mechanisms used to store C++ objects, and some structures even contain all three maps side by side, each following a different principle.",source:"@site/docs/code/serialization-types.md",sourceDirName:"code",slug:"/code/serialization-types",permalink:"/zano-docs/docs/code/serialization-types",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"codeSidebar",previous:{title:"Codebase documents Zano",permalink:"/zano-docs/docs/code/overview"}},l={},c=[{value:"1\u202f\u202fDeterministic Serialization",id:"1deterministic-serialization",level:2},{value:"2\u202f\u202fKey\u2013Value Serialization",id:"2keyvalue-serialization",level:2},{value:"3\u202f\u202fBoost Serialization",id:"3boost-serialization",level:2},{value:"Putting It All Together",id:"putting-it-all-together",level:2}],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"serialization-types-in-the-zano-codebase"},"Serialization Types in the Zano Codebase"),(0,a.kt)("p",null,"In the Zano codebase you may encounter a concept called a ",(0,a.kt)("strong",{parentName:"p"},"serialization map"),". In fact, you will see three different serialization mechanisms used to store C++ objects, and some structures even contain all three maps side by side, each following a different principle.\nHere is an example of declaration of ",(0,a.kt)("strong",{parentName:"p"},"asset_descriptor_base")," structure, that includes 3 different serialization maps. "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'  struct asset_descriptor_base\n  {\n    uint64_t            total_max_supply = 0;\n    uint64_t            current_supply = 0;\n    uint8_t             decimal_point = 0;\n    std::string         ticker;\n    std::string         full_name;\n    std::string         meta_info;\n    crypto::public_key  owner = currency::null_pkey; // consider premultipling by 1/8\n    bool                hidden_supply = false;\n    uint8_t             version = ASSET_DESCRIPTOR_BASE_HF4_VER;\n    //version 1 members\n    boost::optional<crypto::eth_public_key> owner_eth_pub_key; // note: the size is 33 bytes (if present) // NOTE: using boost::optional instead of std::optional because of the Boost compilation issue: https://github.com/boostorg/serialization/issues/319 -- sowle\n    //version 2 members\n    std::vector<asset_descriptor_base_etc_fields> etc;  //container for future use if we would be adding some optional parameters that is not known yet, but without mess related to format version\n\n\n    BEGIN_VERSIONED_SERIALIZE(ASSET_DESCRIPTOR_BASE_LAST_VER, version)\n      FIELD(total_max_supply)\n      FIELD(current_supply)\n      FIELD(decimal_point)\n      FIELD(ticker)\n      FIELD(full_name)\n      FIELD(meta_info)\n      FIELD(owner)\n      FIELD(hidden_supply)\n      END_VERSION_UNDER(1)\n      FIELD(owner_eth_pub_key)\n      END_VERSION_UNDER(2)\n      FIELD(etc)\n    END_SERIALIZE()\n\n    BOOST_SERIALIZATION_CURRENT_ARCHIVE_VER(2)\n    BEGIN_BOOST_SERIALIZATION()\n      BOOST_SERIALIZE(total_max_supply)\n      BOOST_SERIALIZE(current_supply)\n      BOOST_SERIALIZE(decimal_point)\n      BOOST_SERIALIZE(ticker)\n      BOOST_SERIALIZE(full_name)\n      BOOST_SERIALIZE(meta_info)\n      BOOST_SERIALIZE(owner)\n      BOOST_SERIALIZE(hidden_supply)\n      BOOST_END_VERSION_UNDER(1)\n      BOOST_SERIALIZE(owner_eth_pub_key)\n      BOOST_END_VERSION_UNDER(2)\n      BOOST_SERIALIZE(etc)\n      BOOST_SERIALIZE(version)\n    END_BOOST_SERIALIZATION_TOTAL_FIELDS(11)\n\n    BEGIN_KV_SERIALIZE_MAP()\n      KV_SERIALIZE(total_max_supply)  DOC_DSCR("Maximum possible supply for a given asset, cannot be changed after deployment.") DOC_EXMP(1000000000000000000)   DOC_END\n      KV_SERIALIZE(current_supply)    DOC_DSCR("Currently emitted supply for the given asset (ignored for REGISTER operation).") DOC_EXMP(500000000000000000)    DOC_END\n      KV_SERIALIZE(decimal_point)     DOC_DSCR("Decimal point.")                      DOC_EXMP(12)                        DOC_END\n      KV_SERIALIZE(ticker)            DOC_DSCR("Ticker associated with the asset.")   DOC_EXMP("ZABC")                    DOC_END\n      KV_SERIALIZE(full_name)         DOC_DSCR("Full name of the asset.")             DOC_EXMP("Zano wrapped ABC")        DOC_END\n      KV_SERIALIZE(meta_info)         DOC_DSCR("Any other information associated with the asset, by default in a json format.")           DOC_EXMP("{ \\"some_arbitrary_field_name\\": \\"some arbitrary value\\"}")      DOC_END\n      KV_SERIALIZE_POD_AS_HEX_STRING(owner) DOC_DSCR("Owner\'s key, used only for EMIT and UPDATE validation, can be changed by transferring asset ownership.")   DOC_EXMP("f74bb56a5b4fa562e679ccaadd697463498a66de4f1760b2cd40f11c3a00a7a8")        DOC_END\n      KV_SERIALIZE(hidden_supply)     DOC_DSCR("This field is reserved for future use and will be documented later.") DOC_END\n      KV_SERIALIZE_POD_AS_HEX_STRING(owner_eth_pub_key) DOC_DSCR("[Optional] Owner\'s key in the case when ETH signature is used.") DOC_END\n    END_KV_SERIALIZE_MAP()\n  };\n')),(0,a.kt)("p",null,"The Zano project relies on three distinct serialization mechanisms, each chosen for the layer of the system in which it excels. This document explains why Zano employs three distinct serialization methods and clarifies the specific purpose of each one."),(0,a.kt)("h2",{id:"1deterministic-serialization"},"1\u202f\u202fDeterministic Serialization"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Deterministic serialization lies at the heart of the blockchain core.")," (starts from BEGIN_VERSIONED_SERIALIZE) Every cryptographic object \u2014 whether it is a transaction, a block header or any other structures that is a part of currency protocol \u2014 is encoded with this method. The defining guarantee is simple yet crucial: if a structure is read from a byte buffer and immediately written back, the second buffer will be ",(0,a.kt)("strong",{parentName:"p"},"bit\u2011for\u2011bit identical")," to the first, regardless of the binary or software version that performed the operation. Because of this property, cryptographic hashes computed over the data remain stable across platforms and releases, ensuring consensus integrity."),(0,a.kt)("p",null,"Although the implementation borrows the conceptual pattern of ",(0,a.kt)("em",{parentName:"p"},"Boost.Serialization"),", it deliberately supports only the handful of C++ types actually used inside Zano. This focused scope keeps the code compact, so serializing a block or transaction is quite fast. The very same serialization is also used by the on\u2011disk database, due to it's performance properties compared to boost serialization."),(0,a.kt)("p",null,"A small, developer\u2011friendly addition is a ",(0,a.kt)("strong",{parentName:"p"},"one\u2011way JSON exporter"),". When debugging, an object can be dumped to formatted JSON for human inspection. The reverse operation (JSON \u2192 object) is intentionally not supported, preserving the deterministic path."),(0,a.kt)("h2",{id:"2keyvalue-serialization"},"2\u202f\u202fKey\u2013Value Serialization"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Key\u2013value serialization powers all network protocols in Zano and the wider CryptoNote family."),"(starts from BEGIN_KV_SERIALIZE_MAP) Its design revolves around a two\u2011stage pipeline. First, a C++ object is unpacked into an intermediate key\u2013value store where every field is addressed by name. Only then is the store linearized into a byte stream for transport. The reverse path\u2014byte stream \u2192 store \u2192 C++ object\u2014follows the same steps in reverse order."),(0,a.kt)("p",null,"This indirection pays dividends in compatibility. When a newer release introduces an extra field, older nodes simply skip the unfamiliar key during deserialization, while newer nodes treat missing keys as default values. Thanks to this behaviour, ",(0,a.kt)("strong",{parentName:"p"},"forward and backward compatibility come for free"),", without version gates or special\u2011case code."),(0,a.kt)("p",null,"Because the store is already structured as named fields, it can be re\u2011encoded not only as a compact binary blob but also as ",(0,a.kt)("strong",{parentName:"p"},"JSON or XML"),". The JSON form is what enables the wallet\u2019s JSON\u2011RPC interface: wallet and daemon exchange ordinary HTTP messages containing JSON that mirrors their internal C++ structures, yet both sides enjoy compile\u2011time type safety."),(0,a.kt)("h2",{id:"3boost-serialization"},"3\u202f\u202fBoost Serialization"),(0,a.kt)("p",null,"The third and final mechanism is the well\u2011known ",(0,a.kt)("strong",{parentName:"p"},"Boost.Serialization")," library.(starts from BEGIN_BOOST_SERIALIZATION) It is neither trimmed nor specialized; it remains precisely because it can ",(0,a.kt)("strong",{parentName:"p"},"handle virtually any C++ type"),", including sophisticated containers such as ",(0,a.kt)("inlineCode",{parentName:"p"},"boost::variant")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"boost::any"),". Zano employs this flexibility where it matters most: when the wallet needs to persist its entire state to disk. The wallet\u2019s object graph is complex and evolves frequently, and Boost.Serialization allows developers to extend it with minimal boilerplate while preserving backward compatibility of the saved files."),(0,a.kt)("h2",{id:"putting-it-all-together"},"Putting It All Together"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Each serializer lives where it provides the most benefit.")," Deterministic serialization gives the blockchain core the immutability it requires; key\u2013value serialization lets network messages and RPC calls evolve gracefully; Boost.Serialization offers a pragmatic solution for persisting wallet state without bespoke code for every data revision. By deploying the right tool at the right layer, Zano balances performance, robustness, and developer ergonomics across the stack."))}u.isMDXComponent=!0}}]);